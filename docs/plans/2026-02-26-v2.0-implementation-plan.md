# All Weather v2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement daily mean-reversion strategy (v2.0) with per-asset drift checking and parameter tuning.

**Architecture:** New `AllWeatherV2` class extends v1.2 logic with daily drift checks. When any asset drifts beyond threshold, trim/buy that asset back to target. Weekly Monday still updates target weights via risk parity.

**Tech Stack:** Python, pandas, numpy, scipy (existing), pytest for tests

---

## Task 1: Create v2.0 Strategy Class Skeleton

**Files:**
- Create: `src/strategy_v2.py`
- Reference: `src/strategy.py` (v1.2 implementation)

**Step 1: Create the v2.0 strategy file with class skeleton**

```python
"""
All Weather Strategy v2.0 - Daily Mean-Reversion

Extends v1.2 with daily drift checking and per-asset rebalancing.
"""

from typing import Optional, List, Dict
import numpy as np
import pandas as pd

from src.metrics import calculate_all_metrics
from src.optimizer import optimize_weights
from src.portfolio import Portfolio


class AllWeatherV2:
    """
    All Weather Strategy v2.0 - Daily Mean-Reversion

    Key differences from v1.2:
    - Daily drift checking (not just weekly)
    - Per-asset trim/buy (not full portfolio rebalance)
    - Single symmetric drift_threshold parameter

    Version History:
    - v1.0: Pure risk parity, always rebalance
    - v1.1: + Adaptive rebalancing (weekly, 5% drift threshold)
    - v1.2: + Ledoit-Wolf covariance shrinkage
    - v2.0: + Daily mean-reversion (per-asset drift checking)
    """

    def __init__(
        self,
        prices: pd.DataFrame,
        initial_capital: float = 1_000_000,
        lookback: int = 252,
        commission_rate: float = 0.0003,
        drift_threshold: float = 0.05,
        use_shrinkage: bool = True,
    ) -> None:
        """
        Initialize v2.0 strategy.

        Args:
            prices: DataFrame of ETF prices
            initial_capital: Starting capital
            lookback: Days for covariance calculation (252 = 1 year)
            commission_rate: Transaction cost (0.03% = 0.0003)
            drift_threshold: Trigger threshold for per-asset rebalancing (default 5%)
            use_shrinkage: Use Ledoit-Wolf shrinkage (default True)
        """
        self.prices = prices
        self.initial_capital = initial_capital
        self.lookback = lookback
        self.commission_rate = commission_rate
        self.drift_threshold = drift_threshold
        self.use_shrinkage = use_shrinkage

        self.portfolio = Portfolio(initial_capital, commission_rate)
        self.target_weights: Optional[Dict[str, float]] = None
        self.daily_trades: List[Dict] = []

    def run_backtest(
        self,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        verbose: bool = True,
    ) -> dict:
        """Run backtest and return results."""
        raise NotImplementedError("To be implemented in Task 2")
```

**Step 2: Verify file is valid Python**

Run: `cd /Users/zdf/Documents/GitHub/all-weather && python -c "from src.strategy_v2 import AllWeatherV2; print('OK')"`

Expected: `OK`

**Step 3: Commit**

```bash
cd /Users/zdf/Documents/GitHub/all-weather
git add src/strategy_v2.py
git commit -m "feat(v2): add AllWeatherV2 class skeleton"
```

---

## Task 2: Implement Daily Drift Check Logic

**Files:**
- Modify: `src/strategy_v2.py`

**Step 1: Add the check_daily_drift method**

Add after `__init__`:

```python
    def check_daily_drift(self, current_prices: pd.Series) -> List[Dict]:
        """
        Check each asset for drift beyond threshold.

        Returns list of trades needed: [{'asset': str, 'action': 'buy'|'sell', 'drift': float}]
        """
        if self.target_weights is None:
            return []

        trades_needed = []
        current_weights = self.portfolio.get_weights(current_prices)

        for asset, target_weight in self.target_weights.items():
            current_weight = current_weights.get(asset, 0.0)
            drift = current_weight - target_weight

            if abs(drift) > self.drift_threshold:
                action = 'sell' if drift > 0 else 'buy'
                trades_needed.append({
                    'asset': asset,
                    'action': action,
                    'drift': drift,
                    'current_weight': current_weight,
                    'target_weight': target_weight,
                })

        return trades_needed
```

**Step 2: Add the execute_daily_rebalance method**

Add after `check_daily_drift`:

```python
    def execute_daily_rebalance(
        self,
        trades_needed: List[Dict],
        current_prices: pd.Series,
        date: pd.Timestamp,
    ) -> int:
        """
        Execute per-asset rebalancing for assets that drifted beyond threshold.

        Returns number of trades executed.
        """
        if not trades_needed:
            return 0

        # For simplicity, rebalance all drifted assets back to target
        # This is equivalent to a partial rebalance
        portfolio_value = self.portfolio.get_value(current_prices)

        for trade in trades_needed:
            asset = trade['asset']
            target_weight = trade['target_weight']
            target_value = portfolio_value * target_weight
            current_shares = self.portfolio.holdings.get(asset, 0)
            current_value = current_shares * current_prices[asset]

            if trade['action'] == 'sell':
                # Sell excess
                sell_value = current_value - target_value
                sell_shares = sell_value / current_prices[asset]
                if sell_shares > 0:
                    self.portfolio.sell(asset, sell_shares, current_prices[asset])
            else:
                # Buy deficit
                buy_value = target_value - current_value
                buy_shares = buy_value / current_prices[asset]
                if buy_shares > 0 and self.portfolio.cash >= buy_value:
                    self.portfolio.buy(asset, buy_shares, current_prices[asset])

            self.daily_trades.append({
                'date': date,
                'asset': asset,
                'action': trade['action'],
                'drift': trade['drift'],
            })

        return len(trades_needed)
```

**Step 3: Verify methods exist**

Run: `cd /Users/zdf/Documents/GitHub/all-weather && python -c "from src.strategy_v2 import AllWeatherV2; v = AllWeatherV2.__dict__; print('check_daily_drift' in v and 'execute_daily_rebalance' in v)"`

Expected: `True`

**Step 4: Commit**

```bash
cd /Users/zdf/Documents/GitHub/all-weather
git add src/strategy_v2.py
git commit -m "feat(v2): add daily drift check and rebalance methods"
```

---

## Task 3: Implement Backtest Loop

**Files:**
- Modify: `src/strategy_v2.py`

**Step 1: Replace the run_backtest method**

Replace the `raise NotImplementedError` with full implementation:

```python
    def run_backtest(
        self,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        verbose: bool = True,
    ) -> dict:
        """Run backtest with daily drift checking and weekly target updates."""
        start = pd.Timestamp(start_date) if start_date else self.prices.index[self.lookback]
        end = pd.Timestamp(end_date) if end_date else self.prices.index[-1]

        backtest_prices = self.prices.loc[:end].copy()

        # Weekly Mondays for target weight updates
        rebalance_dates = backtest_prices.loc[start:end].resample('W-MON').first().index

        if verbose:
            print(f"Backtest: {start.date()} to {end.date()}")
            print(f"Weekly rebalance dates: {len(rebalance_dates)}")
            print(f"Drift threshold: {self.drift_threshold:.1%}")

        equity_curve = []
        dates = []
        weights_history = []
        daily_rebalance_count = 0
        weekly_rebalance_count = 0

        for date in backtest_prices.loc[start:end].index:
            current_prices = backtest_prices.loc[date]
            portfolio_value = self.portfolio.get_value(current_prices)
            equity_curve.append(portfolio_value)
            dates.append(date)

            # WEEKLY: Update target weights on Mondays
            if date in rebalance_dates:
                lookback_start = backtest_prices.index.get_loc(date) - self.lookback
                if lookback_start < 0:
                    continue

                lookback_end = backtest_prices.index.get_loc(date)
                hist_returns = backtest_prices.iloc[lookback_start:lookback_end].pct_change().dropna()

                if len(hist_returns) < self.lookback - 1:
                    continue

                try:
                    weights = optimize_weights(hist_returns, use_shrinkage=self.use_shrinkage)
                    self.target_weights = dict(zip(backtest_prices.columns, weights))

                    # If no positions yet, do initial allocation
                    if self.portfolio.get_value(current_prices) == self.initial_capital:
                        self.portfolio.rebalance(self.target_weights, current_prices)
                        weekly_rebalance_count += 1

                    weights_history.append({'date': date, **self.target_weights})

                    if verbose:
                        print(f"[{date.date()}] Updated target weights")

                except Exception as e:
                    if verbose:
                        print(f"Error at {date}: {e}")
                    continue

            # DAILY: Check drift and execute per-asset rebalancing
            if self.target_weights is not None:
                trades_needed = self.check_daily_drift(current_prices)
                if trades_needed:
                    n_trades = self.execute_daily_rebalance(trades_needed, current_prices, date)
                    daily_rebalance_count += n_trades
                    if verbose:
                        assets = [t['asset'] for t in trades_needed]
                        print(f"[{date.date()}] Daily rebalance: {assets}")

        # Compile results
        equity_series = pd.Series(equity_curve, index=dates)
        returns = equity_series.pct_change().dropna()

        weights_df = pd.DataFrame(weights_history).set_index('date') if weights_history else pd.DataFrame()

        results = {
            'equity_curve': equity_series,
            'returns': returns,
            'weights_history': weights_df,
            'final_value': equity_curve[-1],
            'total_return': (equity_curve[-1] / self.initial_capital - 1),
            'metrics': calculate_all_metrics(returns, equity_series),
            'daily_rebalance_count': daily_rebalance_count,
            'weekly_rebalance_count': weekly_rebalance_count,
            'daily_trades': self.daily_trades,
        }

        if verbose:
            print(f"\n{'='*60}")
            print("Backtest Complete!")
            print(f"{'='*60}")
            print(f"Weekly target updates: {len(weights_history)}")
            print(f"Daily rebalances: {daily_rebalance_count}")

        return results
```

**Step 2: Test the backtest runs**

Run: `cd /Users/zdf/Documents/GitHub/all-weather && python -c "
from src.strategy_v2 import AllWeatherV2
from src.data_loader import load_prices
prices = load_prices('data/etf_prices_7etf.csv')
strategy = AllWeatherV2(prices, drift_threshold=0.07)
results = strategy.run_backtest('2024-01-01', '2024-03-31', verbose=True)
print(f'Sharpe: {results[\"metrics\"][\"sharpe_ratio\"]:.3f}')
"`

Expected: Backtest output with Sharpe ratio printed

**Step 3: Commit**

```bash
cd /Users/zdf/Documents/GitHub/all-weather
git add src/strategy_v2.py
git commit -m "feat(v2): implement backtest loop with daily drift checking"
```

---

## Task 4: Create Parameter Tuning Script

**Files:**
- Create: `scripts/tune_v2_threshold.py`
- Reference: `scripts/tune_threshold.py` (v1.2 tuning script)

**Step 1: Create the tuning script**

```python
"""
Tune drift_threshold parameter for All Weather v2.0

Train: 2018-2023 (find best threshold)
Validate: 2024 (confirm generalization)
Test: 2025-2026 (final out-of-sample check)
"""

import sys
sys.path.append('.')

import pandas as pd
from src.data_loader import load_prices
from src.strategy_v2 import AllWeatherV2
from src.strategy import AllWeatherV1

# Configuration
THRESHOLDS = [0.03, 0.05, 0.07, 0.10, 0.15]
TRAIN_START = '2018-01-01'
TRAIN_END = '2023-12-31'
VAL_START = '2024-01-01'
VAL_END = '2024-12-31'
TEST_START = '2025-01-01'
TEST_END = None


def run_v2_backtest(prices, threshold, start_date, end_date):
    """Run v2.0 backtest with given threshold."""
    strategy = AllWeatherV2(
        prices=prices,
        initial_capital=1_000_000,
        lookback=252,
        commission_rate=0.0003,
        drift_threshold=threshold,
        use_shrinkage=True
    )
    results = strategy.run_backtest(start_date, end_date, verbose=False)
    return {
        'sharpe': results['metrics']['sharpe_ratio'],
        'return': results['metrics']['annual_return'],
        'max_dd': results['metrics']['max_drawdown'],
        'daily_rebalances': results['daily_rebalance_count'],
        'final_value': results['final_value']
    }


def run_v12_backtest(prices, start_date, end_date):
    """Run v1.2 baseline backtest."""
    strategy = AllWeatherV1(
        prices=prices,
        initial_capital=1_000_000,
        rebalance_freq='W-MON',
        lookback=252,
        commission_rate=0.0003,
        rebalance_threshold=0.05,
        use_shrinkage=True
    )
    results = strategy.run_backtest(start_date, end_date, verbose=False)
    return {
        'sharpe': results['metrics']['sharpe_ratio'],
        'return': results['metrics']['annual_return'],
        'max_dd': results['metrics']['max_drawdown'],
    }


def main():
    print("=" * 70)
    print("V2.0 THRESHOLD TUNING - Daily Mean-Reversion")
    print("=" * 70)

    # Load data
    print("\nLoading data...")
    prices = load_prices('data/etf_prices_7etf.csv')
    print(f"Data range: {prices.index[0].date()} to {prices.index[-1].date()}")

    # === BASELINE ===
    print(f"\n{'=' * 70}")
    print("V1.2 BASELINE")
    print("=" * 70)

    baseline_train = run_v12_backtest(prices, TRAIN_START, TRAIN_END)
    baseline_val = run_v12_backtest(prices, VAL_START, VAL_END)
    print(f"  Training: Sharpe={baseline_train['sharpe']:.3f}, Return={baseline_train['return']:.2%}")
    print(f"  Validation: Sharpe={baseline_val['sharpe']:.3f}, Return={baseline_val['return']:.2%}")

    # === TRAINING PHASE ===
    print(f"\n{'=' * 70}")
    print(f"V2.0 TRAINING PHASE ({TRAIN_START} to {TRAIN_END})")
    print("=" * 70)

    train_results = []
    for threshold in THRESHOLDS:
        metrics = run_v2_backtest(prices, threshold, TRAIN_START, TRAIN_END)
        train_results.append({'threshold': threshold, **metrics})
        print(f"  {threshold:5.0%}: Sharpe={metrics['sharpe']:.3f}, "
              f"Return={metrics['return']:.2%}, MaxDD={metrics['max_dd']:.2%}, "
              f"DailyRebal={metrics['daily_rebalances']}")

    train_df = pd.DataFrame(train_results)
    best_threshold = train_df.loc[train_df['sharpe'].idxmax(), 'threshold']
    best_sharpe = train_df['sharpe'].max()

    print(f"\nBest threshold (training): {best_threshold:.0%} (Sharpe={best_sharpe:.3f})")
    print(f"vs v1.2 baseline: {baseline_train['sharpe']:.3f} ({'+' if best_sharpe > baseline_train['sharpe'] else ''}{best_sharpe - baseline_train['sharpe']:.3f})")

    # === VALIDATION PHASE ===
    print(f"\n{'=' * 70}")
    print(f"V2.0 VALIDATION PHASE ({VAL_START} to {VAL_END})")
    print("=" * 70)

    val_results = []
    for threshold in THRESHOLDS:
        metrics = run_v2_backtest(prices, threshold, VAL_START, VAL_END)
        val_results.append({'threshold': threshold, **metrics})
        print(f"  {threshold:5.0%}: Sharpe={metrics['sharpe']:.3f}, "
              f"Return={metrics['return']:.2%}, MaxDD={metrics['max_dd']:.2%}")

    val_df = pd.DataFrame(val_results)
    val_df['rank'] = val_df['sharpe'].rank(ascending=False).astype(int)

    best_val_rank = val_df.loc[val_df['threshold'] == best_threshold, 'rank'].values[0]
    best_val_sharpe = val_df.loc[val_df['threshold'] == best_threshold, 'sharpe'].values[0]

    validation_passed = best_val_rank <= 3
    status = "PASSED" if validation_passed else "FAILED"
    print(f"\nBest threshold ({best_threshold:.0%}) validation rank: {best_val_rank}/{len(THRESHOLDS)} {status}")
    print(f"vs v1.2 baseline: {baseline_val['sharpe']:.3f}")

    # === TEST PHASE ===
    print(f"\n{'=' * 70}")
    print(f"V2.0 TEST PHASE ({TEST_START} to end)")
    print("=" * 70)

    test_metrics = run_v2_backtest(prices, best_threshold, TEST_START, TEST_END)
    baseline_test = run_v12_backtest(prices, TEST_START, TEST_END)

    print(f"\nThreshold {best_threshold:.0%} test results:")
    print(f"  Sharpe Ratio:     {test_metrics['sharpe']:.3f} (v1.2: {baseline_test['sharpe']:.3f})")
    print(f"  Annual Return:    {test_metrics['return']:.2%} (v1.2: {baseline_test['return']:.2%})")
    print(f"  Max Drawdown:     {test_metrics['max_dd']:.2%} (v1.2: {baseline_test['max_dd']:.2%})")
    print(f"  Daily Rebalances: {test_metrics['daily_rebalances']}")

    # === SUMMARY ===
    print(f"\n{'=' * 70}")
    print("SUMMARY")
    print("=" * 70)

    print("\nTraining Results (sorted by Sharpe):")
    print(train_df.sort_values('sharpe', ascending=False).to_string(index=False))

    improvement = test_metrics['sharpe'] - baseline_test['sharpe']
    recommendation = "ADOPT v2.0" if improvement > 0 and validation_passed else "KEEP v1.2"

    print(f"\n{'â”€' * 70}")
    print(f"RECOMMENDATION: {recommendation}")
    print(f"  Best threshold: {best_threshold:.0%}")
    print(f"  Test Sharpe improvement: {improvement:+.3f}")
    print("=" * 70)


if __name__ == '__main__':
    main()
```

**Step 2: Run the tuning script**

Run: `cd /Users/zdf/Documents/GitHub/all-weather && uv run python scripts/tune_v2_threshold.py`

Expected: Full output showing training, validation, test results and recommendation

**Step 3: Commit**

```bash
cd /Users/zdf/Documents/GitHub/all-weather
git add scripts/tune_v2_threshold.py
git commit -m "feat(v2): add threshold tuning script"
```

---

## Task 5: Run Tuning and Document Results

**Files:**
- Modify: `docs/plans/2026-02-26-v2.0-daily-mean-reversion-design.md` (add results)

**Step 1: Run the full tuning**

Run: `cd /Users/zdf/Documents/GitHub/all-weather && uv run python scripts/tune_v2_threshold.py 2>&1 | tee docs/v2_tuning_results.txt`

**Step 2: Update design doc with results**

Append results summary to the design doc based on actual tuning output.

**Step 3: Commit**

```bash
cd /Users/zdf/Documents/GitHub/all-weather
git add docs/
git commit -m "docs(v2): add tuning results"
```

---

## Summary

| Task | Files | Purpose |
|------|-------|---------|
| 1 | `src/strategy_v2.py` | Class skeleton |
| 2 | `src/strategy_v2.py` | Daily drift check methods |
| 3 | `src/strategy_v2.py` | Backtest loop |
| 4 | `scripts/tune_v2_threshold.py` | Parameter tuning |
| 5 | `docs/` | Document results |
